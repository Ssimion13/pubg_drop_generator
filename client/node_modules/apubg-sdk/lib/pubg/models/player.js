'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _apiModel = require('../apiModel');

var _apiModel2 = _interopRequireDefault(_apiModel);

var _match = require('./match');

var _match2 = _interopRequireDefault(_match);

var _PubgApi = require('../../api/PubgApi');

var _PubgApi2 = _interopRequireDefault(_PubgApi);

var _season = require('./season');

var _season2 = _interopRequireDefault(_season);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class Player
 * @extends ApiModel
 */
var Player = function (_ApiModel) {
    _inherits(Player, _ApiModel);

    /**
     * A new player can be called by newing up with an ID or calling a static Player.get(id)
     *
     * @param {string} id id to search for
     * @param {bool} autoload if searching for an id, set this to false to not immediately make an api call to popualte the player data
     */
    function Player(id) {
        var autoload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        _classCallCheck(this, Player);

        var _this = _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this, id, autoload));

        if (_this.isRecord === false && !id) {
            _this.relationships = {
                matches: {
                    data: []
                }
            };
        }
        return _this;
    }

    _createClass(Player, [{
        key: 'get',


        /**
         * Returns a fetched Player response
         *
         * @param {string} id 
         * @return {Promise}
         * @fulfill {Player}
         */
        value: async function get(id) {
            var _ref = await this.api.get('players/' + id),
                data = _ref.data;

            return this.wrapResponse(data);
        }

        /**
         * Fetch a player by id
         *
         * @param {string} id 
         * @fulfil {Player}
         * @returns {Promise}
         */

    }, {
        key: 'loadSeason',


        /**
         * Load a player's seasonal stats
         *
         * @param {string} season if left null, defaults to the current season 
         * @fulfil {object}
         * @returns {Promise}
         */
        value: async function loadSeason(season) {
            if (!season) {
                var latestSeason = await _season2.default.getCurrent();

                return this.internalLoadSeason(latestSeason.id);
            }

            return this.internalLoadSeason(season);
        }

        /**
         * @private
         * @param {string} season
         * @returns {Promise}
         */

    }, {
        key: 'internalLoadSeason',
        value: async function internalLoadSeason(season) {
            var _ref2 = await this.api.get('players/' + this.id + '/seasons/' + season),
                data = _ref2.data;

            this.relationships.attributes[season] = data.attributes.gameModeStats;

            return data.attributes.gameModeStats;
        }

        /**
         * Search for a player by name
         *
         * @param {string} name
         * @fulfil {Player}
         * @returns {Promise}
         */

    }, {
        key: 'primaryKey',
        get: function get() {
            return "id";
        }

        /**
         * @type {Match[]}
         */

    }, {
        key: 'matches',
        get: function get() {
            return this.isRecord === true ? this.relationships.matches.data.map(function (match) {
                return new _match2.default(match.id, false);
            }) : [];
        }
    }], [{
        key: 'get',
        value: async function get(id) {
            return await new Player(id);
        }
    }, {
        key: 'findByName',
        value: async function findByName(name) {
            var route = 'players?filter[playerName]=' + name;

            var _ref3 = await _PubgApi2.default.get(route),
                data = _ref3.data;

            if (data) {
                return Object.assign(new Player(false, false), data[0], { isRecord: true });
            }

            throw new Error("No results found");
        }
    }]);

    return Player;
}(_apiModel2.default);

exports.default = Player;